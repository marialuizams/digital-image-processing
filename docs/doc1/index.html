<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Unidade 1 · Processamento Digital de Imagens</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Relatório referente aos exercícios 2 - 6."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Unidade 1 · Processamento Digital de Imagens"/><meta property="og:type" content="website"/><meta property="og:url" content="https://marialuizams.github.io/digital-image-processing/"/><meta property="og:description" content="Relatório referente aos exercícios 2 - 6."/><meta property="og:image" content="https://marialuizams.github.io/digital-image-processing/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://marialuizams.github.io/digital-image-processing/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/digital-image-processing/undefined"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/digital-image-processing/js/scrollSpy.js"></script><link rel="stylesheet" href="/digital-image-processing/css/main.css"/><script src="/digital-image-processing/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/digital-image-processing/"><h2 class="headerTitle">Processamento Digital de Imagens</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive siteNavItemActive"><a href="/digital-image-processing/docs/doc1" target="_self">Unidade 1</a></li><li class="siteNavGroupActive"><a href="/digital-image-processing/docs/doc2" target="_self">Unidade 2</a></li><li class="siteNavGroupActive"><a href="/digital-image-processing/docs/doc3" target="_self">Unidade 3</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Unidade 1</h1></header><article><div><span><p>Relatório referente aos exercícios 2 - 6.</p>
<h2><a class="anchor" aria-hidden="true" id="manipulando-pixels-em-uma-imagem"></a><a href="#manipulando-pixels-em-uma-imagem" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Manipulando pixels em uma imagem</h2>
<h3><a class="anchor" aria-hidden="true" id="região-negativa"></a><a href="#região-negativa" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Região negativa</h3>
<p>O primeiro exercício da seção consiste em implementar um programa <code>regions.cpp</code>, que solicita ao usuário as coordenadas de dois pontos e exibe o negativo da região definida por eles.</p>
<p>Após a leitura da imagem e a solicitação das coordenadas de cada ponto, é necessário verificar se eles estão localizados dentro dos limites do tamanho da imagem e se P2 &gt; P1. Essa verificação é feita nas funções <code>isvalid()</code> e <code>isgreater()</code>.</p>
<pre><code class="hljs css language-cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isvalid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> w, <span class="hljs-keyword">int</span> h)</span> </span>{
    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || x &gt; w) 
    {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">if</span> (y &lt; <span class="hljs-number">0</span> || y &gt; h)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}

<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isgreater</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> y1, <span class="hljs-keyword">int</span> y2)</span> </span>{
    <span class="hljs-keyword">if</span> (x1 &gt; x2 || y1 &gt; y2)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
</code></pre>
<p>Para calcular o negativo, subtraímos o valor de cada pixel da imagem de 255.</p>
<pre><code class="hljs css language-cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = x1; i &lt; x2; i++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = y1; j &lt; y2; j++) {
        image.at&lt;uchar&gt;(i, j) = <span class="hljs-number">255</span> - image.at&lt;uchar&gt;(i, j);
    }
}
</code></pre>
<p>A saída do programa é mostrada na imagem abaixo.</p>
<p><img src="/digital-image-processing/docs/assets/negativo.PNG" alt=""></p>
<h3><a class="anchor" aria-hidden="true" id="trocando-regiões"></a><a href="#trocando-regiões" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Trocando regiões</h3>
<p>O segundo exercício pede a implementação de um programa <code>swapregions.cpp</code>, que deve receber uma imagem e trocar os seus quadrantes. Para fazer essa troca, 4 novas regiões são criadas a partir da imagem de entrada usando a classe <code>Mat</code>, cada uma dessas regiões recebeu um quadrante da imagem.</p>
<pre><code class="hljs css language-cpp"><span class="hljs-function">cv::Mat <span class="hljs-title">one</span><span class="hljs-params">(image, Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, (width / <span class="hljs-number">2</span>), (height / <span class="hljs-number">2</span>)))</span></span>;
<span class="hljs-function">cv::Mat <span class="hljs-title">two</span><span class="hljs-params">(image, Rect((width / <span class="hljs-number">2</span>), <span class="hljs-number">0</span>, (width / <span class="hljs-number">2</span>), (height / <span class="hljs-number">2</span>)))</span></span>;
<span class="hljs-function">cv::Mat <span class="hljs-title">three</span><span class="hljs-params">(image, Rect(<span class="hljs-number">0</span>, (height / <span class="hljs-number">2</span>), (width / <span class="hljs-number">2</span>), (height / <span class="hljs-number">2</span>)))</span></span>;
<span class="hljs-function">cv::Mat <span class="hljs-title">four</span><span class="hljs-params">(image, Rect((width / <span class="hljs-number">2</span>), (height / <span class="hljs-number">2</span>), (width / <span class="hljs-number">2</span>), (height/<span class="hljs-number">2</span>)))</span></span>;
</code></pre>
<p>Os quadrantes são então concatenados para formar a imagem de saída.</p>
<pre><code class="hljs css language-cpp">cv::Mat first, second;
    
cv::vconcat(four, two, first);
cv::vconcat(three, one, second);

cv::hconcat(first, second, image);
</code></pre>
<p>A saída do programa é mostrada a seguir.</p>
<p><img src="/digital-image-processing/docs/assets/swapregions.PNG" alt=""></p>
<h2><a class="anchor" aria-hidden="true" id="preenchendo-regiões"></a><a href="#preenchendo-regiões" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Preenchendo regiões</h2>
<p>Esse exercício pede para que o algoritmo de contagem seja aprimorado, fazendo com que seja possível identificar bolhas com ou sem buracos internos, excluindo as bolhas que tocam as bordas da imagem.</p>
<p><img src="/digital-image-processing/docs/assets/bolhas.png" alt=""></p>
<p>Para retirar as bolhas das bordas, percorre-se as primeiras e últimas linhas e colunas da imagem em busca de elementos com tom de cinza igual a 255. Quando encontrado, a função <code>floodfill</code> é chamada utilizando o pixel encontrado como semente, rotulando a região com tom de cinza 0.</p>
<pre><code class="hljs css language-cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; height; i++)
{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; width; j++)
    {
        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || i == height - <span class="hljs-number">1</span> || j == <span class="hljs-number">0</span> || j == width - <span class="hljs-number">1</span>)
        {
            <span class="hljs-keyword">if</span> (image.at&lt;uchar&gt;(i, j) == <span class="hljs-number">255</span>)
            {
                p.x = j;
                p.y = i;
                floodFill(image, p, <span class="hljs-number">0</span>);
            }
        }
    }
}
</code></pre>
<p><img src="/digital-image-processing/docs/assets/borders.PNG" alt=""></p>
<p>A imagem é entao rotulada usando o algoritmo de contagem apresentado no código original <code>labeling.cpp</code> e a cor de fundo é trocada para o tom de cinza 255.</p>
<pre><code class="hljs css language-cpp">nobjects = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; height; i++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; width; j++) {
        <span class="hljs-keyword">if</span> (image.at&lt;uchar&gt;(i, j) == <span class="hljs-number">255</span>)
        {
            nobjects++;
            p.x = j;
            p.y = i;
            
            cv::floodFill(image, p, nobjects);
        }
    }
}

p.x = <span class="hljs-number">0</span>;
p.y = <span class="hljs-number">0</span>;

cv:floodFill(image, p, <span class="hljs-number">255</span>);
</code></pre>
<p><img src="/digital-image-processing/docs/assets/whitebg.PNG" alt=""></p>
<p>Inicia-se então um contador <code>holes</code> para armazenar a quantidade de bolhas com buracos. Para encontrar essas bolhas, percorre-se as linhas e colunas da matriz em busca de elementos com tom de cinza igual a 0. Uma vez que um elemento é encontrado, o contador é incrementado e o algoritmo <code>floodfill</code> é executado duas vezes, uma usando o pixel encontrado (<code>p.x = j</code> e <code>p.y = i</code>) como semente e outra usando o pixel à sua esquerda (<code>p.x = j-1</code> e <code>p.y = i</code>), rotulando a região com tom de cinza 255.</p>
<pre><code class="hljs css language-cpp">holes = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; height; i++) 
{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; width; j++) 
    {
        <span class="hljs-keyword">if</span> (image.at&lt;uchar&gt;(i, j) == <span class="hljs-number">0</span>) 
        {
            holes++;
            p.x = j;
            p.y = i;
            floodFill(image, p, <span class="hljs-number">255</span>);
            p.x = j - <span class="hljs-number">1</span>;
            floodFill(image, p, <span class="hljs-number">255</span>);
        }
    }
}

<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"a figura tem "</span> &lt;&lt; nobjects &lt;&lt; <span class="hljs-string">" bolhas\n"</span>;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; holes &lt;&lt; <span class="hljs-string">" bolhas com buracos e "</span> &lt;&lt; (nobjects - holes) &lt;&lt; <span class="hljs-string">" bolhas sem buracos\n"</span>;
</code></pre>
<p>A saída do programa é apresentado a seguir.</p>
<p><img src="/digital-image-processing/docs/assets/labeling.PNG" alt=""></p>
<pre><code class="hljs css language-c">A figura tem <span class="hljs-number">21</span> bolhas.
<span class="hljs-number">7</span> bolhas com buracos e <span class="hljs-number">14</span> bolhas sem buracos.
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="manipulação-de-histogramas"></a><a href="#manipulação-de-histogramas" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Manipulação de histogramas</h2>
<h3><a class="anchor" aria-hidden="true" id="equalização-de-histograma"></a><a href="#equalização-de-histograma" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Equalização de histograma</h3>
<p>No exercício de equalização, pede-se que, para cada imagem capturada, seja realizada uma equalização do seu histograma antes de exibi-la. A captura de vídeo é feita através da classe <code>VideoCapture</code> do OpenCV.</p>
<p>A equalização é feita através da função <code>equalizeHist()</code>  dentro do loop de captura das imagens. Os histogramas da imagem original e da imagem equalizada são calculados e mostrados na tela junto com as imagens capturadas.</p>
<pre><code class="hljs css language-cpp"><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
    cap &gt;&gt; image;
    cvtColor(image, image, cv::COLOR_BGR2GRAY);
    equalizeHist(image, eq_image);

    cv::calcHist(&amp;image, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, cv::Mat(), hist, <span class="hljs-number">1</span>, &amp;nbins, &amp;histrange, uniform, accumulate);
    cv::calcHist(&amp;eq_image, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, cv::Mat(), histEq, <span class="hljs-number">1</span>, &amp;nbins, &amp;histrange, uniform, accumulate);

    cv::normalize(hist, hist, <span class="hljs-number">0</span>, histImg.rows, cv::NORM_MINMAX, <span class="hljs-number">-1</span>, cv::Mat());
    cv::normalize(histEq, histEq, <span class="hljs-number">0</span>, histImgEq.rows, cv::NORM_MINMAX, <span class="hljs-number">-1</span>, cv::Mat());

    histImg.setTo(cv::Scalar(<span class="hljs-number">0</span>));
    histImgEq.setTo(cv::Scalar(<span class="hljs-number">0</span>));

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nbins; i++) {
        cv::line(histImg,
            cv::Point(i, histh),
            cv::Point(i, histh - cvRound(hist.at&lt;<span class="hljs-keyword">float</span>&gt;(i))),
            cv::Scalar(<span class="hljs-number">255</span>), <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>);
    }

    histImg.copyTo(image(cv::Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, nbins, histh)));

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nbins; i++) {
        cv::line(histImgEq,
            cv::Point(i, histh),
            cv::Point(i, histh - cvRound(histEq.at&lt;<span class="hljs-keyword">float</span>&gt;(i))),
            cv::Scalar(<span class="hljs-number">255</span>), <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>);
    }

    histImgEq.copyTo(eq_image(cv::Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, nbins, histh)));

    cv::imshow(<span class="hljs-string">"image"</span>, image);
    cv::imshow(<span class="hljs-string">"equalized image"</span>, eq_image);

    key = cv::waitKey(<span class="hljs-number">30</span>);  
    <span class="hljs-keyword">if</span> (key == <span class="hljs-number">27</span>) <span class="hljs-keyword">break</span>;
}
</code></pre>
<p><img src="/digital-image-processing/docs/assets/equalize.PNG" alt=""></p>
<p><img src="/digital-image-processing/docs/assets/equalize2.png" alt=""></p>
<h3><a class="anchor" aria-hidden="true" id="detector-de-movimentos"></a><a href="#detector-de-movimentos" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Detector de movimentos</h3>
<p>No segundo exercício da seção 4, pede-se para implementar um programa <code>motiondetector.cpp</code>, que calcula o histograma da imagem de forma contínua e o compara com o último histograma calculado, ativando um alarme quando um limiar pré-estabelecido for ultrapassado. Para este exercício, apenas o histograma da componente de cor vermelha foi considerado.</p>
<p>Após o cálculo do histograma de dois frames, a função <code>compareHist()</code> é executada utilizando o método da distância de Bhattacharyya para calcular a diferença. Calculada a diferença entre os histogramas, o valor resultante é comparado com o limiar escolhido (7). Se a diferença for maior, um quadrado vermelho é exibido na imagem e a frase <code>Movimento detectado!</code> é exibida no terminal.</p>
<pre><code class="hljs css language-cpp">cap &gt;&gt; frame1;
cv::split(frame1, planes);
cv::calcHist(&amp;planes[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, cv::Mat(), histR1, <span class="hljs-number">1</span>, &amp;nbins, &amp;histrange, uniform, acummulate);

cv::normalize(histR1, histR1, <span class="hljs-number">0</span>, histImgR.rows, cv::NORM_MINMAX, <span class="hljs-number">-1</span>, cv::Mat());

histImgR.setTo(cv::Scalar(<span class="hljs-number">0</span>));

cap &gt;&gt; frame2;
cv::split(frame2, planes);
cv::calcHist(&amp;planes[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, cv::Mat(), histR2, <span class="hljs-number">1</span>, &amp;nbins, &amp;histrange, uniform, acummulate);

cv::normalize(histR2, histR2, <span class="hljs-number">0</span>, histImgR.rows, cv::NORM_MINMAX, <span class="hljs-number">-1</span>, cv::Mat());

comp = compareHist(histR1, histR2, <span class="hljs-number">4</span>);

val[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;   <span class="hljs-comment">//B</span>
val[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;   <span class="hljs-comment">//G</span>
val[<span class="hljs-number">2</span>] = <span class="hljs-number">255</span>; <span class="hljs-comment">//R</span>

<span class="hljs-keyword">if</span> (comp &gt; <span class="hljs-number">7</span>) {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Movimento detectado!"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">420</span>; i &lt; <span class="hljs-number">460</span>; i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">580</span>; j &lt; <span class="hljs-number">620</span>; j++) {
            frame1.at&lt;Vec3b&gt;(i, j) = val;
        }
    }
}
</code></pre>
<p><img src="/digital-image-processing/docs/assets/motiondetector.PNG" alt=""></p>
<h2><a class="anchor" aria-hidden="true" id="filtragem-no-domínio-espacial"></a><a href="#filtragem-no-domínio-espacial" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Filtragem no domínio espacial</h2>
<h3><a class="anchor" aria-hidden="true" id="filtro-laplaciano-do-gaussiano"></a><a href="#filtro-laplaciano-do-gaussiano" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Filtro laplaciano do gaussiano</h3>
</span></div></article></div><div class="docs-prevnext"><a class="docs-next button" href="/digital-image-processing/docs/doc2"><span>Unidade 2</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#manipulando-pixels-em-uma-imagem">Manipulando pixels em uma imagem</a><ul class="toc-headings"><li><a href="#região-negativa">Região negativa</a></li><li><a href="#trocando-regiões">Trocando regiões</a></li></ul></li><li><a href="#preenchendo-regiões">Preenchendo regiões</a></li><li><a href="#manipulação-de-histogramas">Manipulação de histogramas</a><ul class="toc-headings"><li><a href="#equalização-de-histograma">Equalização de histograma</a></li><li><a href="#detector-de-movimentos">Detector de movimentos</a></li></ul></li><li><a href="#filtragem-no-domínio-espacial">Filtragem no domínio espacial</a><ul class="toc-headings"><li><a href="#filtro-laplaciano-do-gaussiano">Filtro laplaciano do gaussiano</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="copyright">Maria Luiza Salviano &lt;luizasalviano@gmail.com&gt;</section></footer></div></body></html>